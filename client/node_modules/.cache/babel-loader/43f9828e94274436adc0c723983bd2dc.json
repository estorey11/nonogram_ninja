{"ast":null,"code":"import { transpose } from 'mathjs';\nexport function fetchNonograms() {\n  return dispatch => {\n    dispatch({\n      type: 'START_NON_REQUEST'\n    });\n    return fetch('/nonograms').then(response => response.json()).then(nonograms => dispatch({\n      type: 'ADD_NONOGRAMS',\n      nonograms\n    }));\n  };\n}\nexport function rightClickCell(coords) {\n  return dispatch => dispatch({\n    type: 'RIGHT_CLICK_CELL',\n    coords\n  });\n}\n\nfunction createSolutionGrid(height, width, solution) {\n  let grid = [];\n  let row = [];\n\n  for (let y = 0; y < height; y++) {\n    row = [];\n\n    for (let x = 0; x < width; x++) {\n      row[x] = parseInt(solution.charAt(y * width + x));\n    }\n\n    grid[y] = row;\n  }\n\n  return grid;\n}\n\nfunction createRowClues(grid) {\n  let rowClues = grid.map(row => {\n    let clues = [0];\n    let chunk = -1;\n    let chunking = false;\n\n    for (let i = 0; i < row.length; i++) {\n      if (row[i] === 1 && chunking === false) {\n        chunking = true;\n        chunk++;\n        clues[chunk] = 1;\n      } else if (row[i] === 1 && chunking === true) {\n        clues[chunk]++;\n      } else if (row[i] === 0 && chunking === true) {\n        chunking = false;\n      }\n    }\n\n    return clues;\n  });\n  return rowClues;\n}\n\nexport function mouseDownOnCell(coords) {\n  return dispatch => dispatch({\n    type: 'MOUSE_DOWN_ON_CELL',\n    coords\n  });\n}\nexport function mouseOverCell(coords) {\n  return dispatch => dispatch({\n    type: 'MOUSE_OVER_CELL',\n    coords\n  });\n}\nexport function mouseUp() {\n  return dispatch => dispatch({\n    type: 'MOUSE_UP'\n  });\n}\nexport function setSolutionAndCluesFromSpecs(height, width, solution) {\n  const gridSolution = createSolutionGrid(height, width, solution);\n  const rowClues = createRowClues(gridSolution);\n  const colClues = createRowClues(transpose(gridSolution));\n  const grid = gridSolution.map(row => row.map(cell => 0));\n  return dispatch => dispatch({\n    type: 'SET_GRID_SOLUTION_AND_CLUES',\n    gridSolution,\n    rowClues,\n    colClues,\n    grid\n  });\n}\nexport function seeSolution(wrongCellCoords, gridSolution) {\n  let grid = gridSolution;\n  wrongCellCoords.forEach(coords => grid[coords[1]][coords[0]] += 2);\n  return dispatch => dispatch({\n    type: 'SEE_SOLUTION',\n    grid\n  });\n}","map":{"version":3,"sources":["/Users/eric_storey/Desktop/Flatiron/nonogram_ninja/client/src/actions/nonActions.js"],"names":["transpose","fetchNonograms","dispatch","type","fetch","then","response","json","nonograms","rightClickCell","coords","createSolutionGrid","height","width","solution","grid","row","y","x","parseInt","charAt","createRowClues","rowClues","map","clues","chunk","chunking","i","length","mouseDownOnCell","mouseOverCell","mouseUp","setSolutionAndCluesFromSpecs","gridSolution","colClues","cell","seeSolution","wrongCellCoords","forEach"],"mappings":"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","sourcesContent":["import { transpose } from 'mathjs'\n\nexport function fetchNonograms() {\n  return (dispatch) => {\n    dispatch({ type: 'START_NON_REQUEST' });\n    return fetch('/nonograms')\n      .then(response => response.json())\n      .then(nonograms => dispatch({ type: 'ADD_NONOGRAMS', nonograms }));\n  };\n}\n\nexport function rightClickCell(coords){\n  return (dispatch)=> dispatch({type: 'RIGHT_CLICK_CELL', coords})\n}\n\n\nfunction createSolutionGrid(height, width, solution){\n  let grid=[]\n  let row=[]\n\n  for (let y = 0; y < height; y++){\n    row=[]\n    for (let x = 0; x < width; x++){\n      row[x]=parseInt(solution.charAt(y*width+x))\n    }\n\n    grid[y]=row\n\n  }\n\n  return grid\n}\n\nfunction createRowClues(grid){\n  let rowClues=grid.map(row=>{\n\n    let clues=[0]\n    let chunk=-1\n    let chunking=false\n    for (let i = 0; i < row.length; i++){\n      if (row[i]===1 && chunking===false){\n        chunking=true\n        chunk++\n        clues[chunk]=1\n      }\n      else if (row[i]===1 && chunking===true) {\n        clues[chunk]++\n      }\n      else if (row[i]===0 && chunking===true) {\n        chunking=false\n      }\n    }\n    return clues\n  })\n\n  return rowClues\n}\n\nexport function mouseDownOnCell(coords) {\n  return (dispatch)=> dispatch({type: 'MOUSE_DOWN_ON_CELL', coords})\n}\n\nexport function mouseOverCell(coords){\n  return (dispatch)=> dispatch({type: 'MOUSE_OVER_CELL', coords})\n}\n\nexport function mouseUp(){\n  return (dispatch)=> dispatch({type: 'MOUSE_UP',})\n}\n\nexport function setSolutionAndCluesFromSpecs(height, width, solution){\n  const gridSolution=createSolutionGrid(height, width, solution)\n  const rowClues=createRowClues(gridSolution)\n  const colClues=createRowClues(transpose(gridSolution))\n  const grid=gridSolution.map(row=> row.map( cell=> 0))\n\n  return (dispatch)=> dispatch({type: 'SET_GRID_SOLUTION_AND_CLUES', gridSolution, rowClues, colClues, grid})\n}\n\nexport function seeSolution(wrongCellCoords, gridSolution){\n  let grid= gridSolution\n\n  wrongCellCoords.forEach(coords=>\n    grid[coords[1]][coords[0]]+=2\n  )\n\n  return (dispatch)=> dispatch({type: 'SEE_SOLUTION', grid})\n}\n"]},"metadata":{},"sourceType":"module"}